---
title: MySQL
categories:
  - 秋招
date: 2024-07-21 20:42:54
tags:
password: 12345m
---

<!-- more -->

# MySQL

## 基础篇

### Mysql语句执行

#### **执行流程**

两层架构：server层和存储引擎层（Innodb ）

1. 连接器
2. 查询缓存
3. 解析SQL
4. 执行SQL

**查看mysql服务被多少客户端连接**：`show processlist;`

**如何解决mysql长连接占用内存的问题**：

mysql的连接基于tcp，和http一样，有短连接和长连接的区别，使用长连接的好处就是可以减少建立连接和断开连接的过程，但使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果**长连接累计很多，将导致 MySQL 服务占用内存太大**，从而被系统强制杀掉，则MySQL 服务异常重启。

查询缓存：always鸡肋（MySQL 8.0 版本后再无查询缓存）。这里说的查询缓存是 server 层的，也就是 MySQL 8.0 版本移除的是 server 层的查询缓存，并不是 Innodb 存储引擎中的 buffer pool。

**执行三阶段**：

- prepare ，预处理；
- optimize，优化；（**优化器主要负责将 SQL 查询语句的执行方案确定下来**，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。）
- execute，执行；
  - 主键索引查询
  - 全表扫描
  - 索引下推

## 索引篇

### 什么是索引

什么是索引：类似书的目录



什么是存储引擎：存数据、建索引、更新查询数据等技术的实现方法。Mysql的引擎有MyISAM 、**InnoDB**（5.5后成为default引擎）、Memory。



索引分类：

- 按数据结构：**B+Tree索引**，hash索引，Full-text索引
- 按物理存储：主键索引（聚簇索引）、二级索引（辅助索引）（均默认以B+Tree索引实现）
- 按字段特性：主键索引、唯一索引、普通索引、前缀索引
- 按字段个数：单列索引、联合索引。

### B+Tree索引

B+Tree：

- 多路平衡搜索树
- 叶子节点才存放数据，非叶子节点只存放索引
- 每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息
- 叶子节点之间为双向链表



主键索引查询与二级索引查询：

- 主键索引的 B+Tree 的叶子节点存放的是实际数据，而二级索引的 B+Tree 的叶子节点仅存放主键值，**无实际数据**
- 二次索引查询数据，需要查询两个B+Tree（回表）。除非仅查主键如select id from product where product_no = '0002';  id为主键。——**覆盖索引**，无需回表



B+Tree与其他对比：

跟Btree：单个节点数据量小且其双链表结构适用于基于范围的顺序查找

跟二叉树：每层节点多， 层高低（I/O操作少，每访问一层即一次I/O操作）

跟Hash：hash仅适用于等值查询

[详细介绍B+Tree的优势](https://mp.weixin.qq.com/s/w1ZFOug8-Sa7ThtMnlaUtQ)

[B+Tree 相比于 B 树、二叉树或 Hash 索引结构的优势在哪儿？](https://xiaolincoding.com/mysql/index/index_interview.html#为什么-mysql-innodb-选择-b-tree-作为索引的数据结构)

### 联合索引



### 索引常见问题

#### 优化索引的方法

- 前缀索引优化；
- 覆盖索引优化；
- 主键索引最好是自增的；
- 防止索引失效； 模糊匹配会导致索引失效

## 事务篇

- 原子性：一个事务中的所有操作，要么全完成，要么全不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态
- 一致性
- 隔离性
- 持久性

InnoDB 引擎通过以下技术保证事务的四个特性：

- 持久性是通过 redo log （重做日志）来保证的；
- 原子性是通过 undo log（回滚日志） 来保证的；
- 隔离性是通过 **MVCC**（多版本并发控制） 或锁机制来保证的；
- 一致性则是通过持久性+原子性+隔离性来保证；

### 并行事务的问题

**脏读**：一个事读到了另一个「未提交事务修改过的数据」（读到了中间值，而这个中间值有可能会因回滚而变成无效数据）

**不可重复读**：一个事务内，前后两次读到的数据不一样

**幻读：**一个事务内，前后两次查询到的<u>记录数量</u>不一样

脏读>不可重复读>幻读

### 事务隔离级别

(按隔离水平从低到高排序)

1. **读未提交（read uncommitted）**，指一个事务还没提交时，它做的变更就能被其他事务看到；
2. **读提交（read committed）**，指一个事务提交之后，它做的变更才能被其他事务看到；
3. **可重复读（repeatable read）**，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**；
4. **串行化（serializable）**；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；



MySQL 在「可重复读」隔离级别下，可以很大程度上避免幻读现象的发生，所以 MySQL 并不会使用「串行化」隔离级别来避免幻读现象的发生，因为 串行化 会影响性能。



实现：

- 对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；
- 对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；
- 对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 **Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View**。



**什么是MVCC**：

MVCC全称是多版本并发控制 (Multi-Version Concurrency Control)，只有在InnoDB引擎下存在。MVCC机制的作用其实就是避免同一个数据在不同事务之间的竞争，提高系统的并发性能。

它的特点如下：

- 允许多个版本同时存在，并发执行。
- **不依赖锁机制，性能高。**
- 只在读已提交和可重复读的事务隔离级别下工作。



### Read View 在 MVCC 里如何工作的？

聚簇索引





参考链接：

[图解MySQL介绍 | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/mysql/)
