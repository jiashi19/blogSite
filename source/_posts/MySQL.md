---
title: MySQL
categories:
  - 秋招
date: 2024-07-21 20:42:54
tags:
password: 12345m
---

<!-- more -->

# MySQL

## 基础篇

### Mysql语句执行

#### **执行流程**

两层架构：server层和存储引擎层（Innodb ）

1. 连接器
2. 查询缓存
3. 解析SQL
4. 执行SQL

**查看mysql服务被多少客户端连接**：`show processlist;`

**如何解决mysql长连接占用内存的问题**：

mysql的连接基于tcp，和http一样，有短连接和长连接的区别，使用长连接的好处就是可以减少建立连接和断开连接的过程，但使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果**长连接累计很多，将导致 MySQL 服务占用内存太大**，从而被系统强制杀掉，则MySQL 服务异常重启。

查询缓存：always鸡肋（MySQL 8.0 版本后再无查询缓存）。这里说的查询缓存是 server 层的，也就是 MySQL 8.0 版本移除的是 server 层的查询缓存，并不是 Innodb 存储引擎中的 buffer pool。

**执行三阶段**：

- prepare ，预处理；
- optimize，优化；（**优化器主要负责将 SQL 查询语句的执行方案确定下来**，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。）
- execute，执行；
  - 主键索引查询
  - 全表扫描
  - 索引下推

## 索引篇

### 什么是索引

什么是索引：类似书的目录



什么是存储引擎：存数据、建索引、更新查询数据等技术的实现方法。Mysql的引擎有MyISAM 、**InnoDB**（5.5后成为default引擎）、Memory。



索引分类：

- 按数据结构：**B+Tree索引**，hash索引，Full-text索引
- 按物理存储：主键索引（聚簇索引）、二级索引（辅助索引）（均默认以B+Tree索引实现）
- 按字段特性：主键索引、唯一索引、普通索引、前缀索引
- 按字段个数：单列索引、联合索引。

### B+Tree索引

B+Tree：

- 多路平衡搜索树
- 叶子节点才存放数据，非叶子节点只存放索引
- 每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息
- 叶子节点之间为双向链表



主键索引查询与二级索引查询：

- 主键索引的 B+Tree 的叶子节点存放的是实际数据，而二级索引的 B+Tree 的叶子节点仅存放主键值，**无实际数据**
- 二次索引查询数据，需要查询两个B+Tree（回表）。除非仅查主键如select id from product where product_no = '0002';  id为主键。——**覆盖索引**，无需回表



B+Tree与其他对比：

跟Btree：单个节点数据量小且其双链表结构适用于基于范围的顺序查找

跟二叉树：每层节点多， 层高低（I/O操作少，每访问一层即一次I/O操作）

跟Hash：hash仅适用于等值查询

[详细介绍B+Tree的优势](https://mp.weixin.qq.com/s/w1ZFOug8-Sa7ThtMnlaUtQ)

[B+Tree 相比于 B 树、二叉树或 Hash 索引结构的优势在哪儿？](https://xiaolincoding.com/mysql/index/index_interview.html#为什么-mysql-innodb-选择-b-tree-作为索引的数据结构)

### 联合索引

多个字段组合成一个索引.
例如对a,b字段创建(a,b)联合索引，联合索引会先按a排序，再按b排序（a全局有序，b局部有序，全局无序）.
最左匹配原则. where a=1 and b=2与where b=2 and c=3，后者无法利用索引.

**联合索引范围查询**
范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。

**索引下推ICP**
select * from t_table where a > 1 and b = 2 ;
减少回表次数：MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

### 索引常见问题

#### 优化索引的方法

- 前缀索引优化；
- 覆盖索引优化：对要查询的数据建立联合索引
- 主键索引最好是自增的；
- 防止索引失效； 模糊匹配会导致索引失效

#### 如何知道语句是否走索引查询
explain查看SQL的执行计划，这样就知道是否命中索引了.

explain select * from xxx;
查询结果重点关注[type](https://javabetter.cn/interview/mysql-suoyin-15.html#_1-2-1-type), rows(估算需读取的行数)


## 事务篇

- 原子性：一个事务中的所有操作，要么全完成，要么全不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态
- 一致性
- 隔离性
- 持久性

InnoDB 引擎通过以下技术保证事务的四个特性：

- 持久性是通过 redo log （重做日志）来保证的；
- 原子性是通过 undo log（回滚日志） 来保证的；
- 隔离性是通过 **MVCC**（多版本并发控制） 或锁机制来保证的；
- 一致性则是通过持久性+原子性+隔离性来保证；

### 并行事务的问题

**脏读**：一个事读到了另一个「未提交事务修改过的数据」（读到了中间值，而这个中间值有可能会因回滚而变成无效数据）

**不可重复读**：一个事务内，前后两次读到的数据不一样

**幻读：**一个事务内，前后两次查询到的<u>记录数量</u>不一样

脏读>不可重复读>幻读

### 事务隔离级别

(按隔离水平从低到高排序)

1. **读未提交（read uncommitted）**，指一个事务还没提交时，它做的变更就能被其他事务看到；
2. **读提交（read committed）**，指一个事务提交之后，它做的变更才能被其他事务看到；
3. **可重复读（repeatable read）**，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**；
4. **串行化（serializable）**；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；



MySQL 在「可重复读」隔离级别下，可以很大程度上避免幻读现象的发生，所以 MySQL 并不会使用「串行化」隔离级别来避免幻读现象的发生，因为 串行化 会影响性能。



实现：

- 对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；
- 对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；
- 对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 **Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View**。



**什么是MVCC**：

MVCC全称是多版本并发控制 (Multi-Version Concurrency Control)，只有在InnoDB引擎下存在。MVCC机制的作用其实就是避免同一个数据在不同事务之间的竞争，提高系统的并发性能。

它的特点如下：

- 允许多个版本同时存在，并发执行。
- **不依赖锁机制，性能高。**
- 只在读已提交和可重复读的事务隔离级别下工作。



### Read View 在 MVCC 里如何工作的？

聚簇索引

## 日志篇
3个日志：
undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的**原子性**，主要用于事务回滚和 MVCC。

redo log（重做日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的**持久性**，主要用于掉电等故障恢复；

binlog （归档日志）：是 Server 层生成的日志，主要用于数据备份和**主从复制**；

### undo log
#### 1. 原子性
undo log是一种用于撤销回退的日志。在事务没提交之前，MySQL会先记录更新前的数据到undo log日志文件里面，当事务回滚时，可以利用undo log来进行回滚。
#### 2. MVCC
https://xiaolincoding.com/mysql/log/how_update.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-undo-log


### Buffer Pool 
Innodb 存储引擎设计了一个缓冲池（Buffer Pool），来提高数据库的读写性能。
- 当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。
- 当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页**设置为脏页**（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/%E7%BC%93%E5%86%B2%E6%B1%A0.drawio.png)


buffer pool中有undo页，开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log会写入Buffer Pool中的Undo页面。
### redo log
当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存(buffer Pool)（同时标记为脏页），然后将本次对这个页的修改以redo log 的形式记录下来，这个时候更新就算完成了。
后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 WAL（Write-Ahead Logging）技术。
WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。

**redo log与undo log比较**：
redo log 记录了此次事务「完成后」的数据状态，记录的是更新之后的值；
undo log 记录了此次事务「开始前」的数据状态，记录的是更新之前的值；
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%BA%8B%E5%8A%A1%E6%81%A2%E5%A4%8D.png)





参考链接：

[图解MySQL介绍 | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/mysql/)
